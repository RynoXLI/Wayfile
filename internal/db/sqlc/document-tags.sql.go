// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: document-tags.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addDocumentTag = `-- name: AddDocumentTag :exec
INSERT INTO document_tags (document_id, tag_id, attributes, attributes_metadata)
VALUES ($1, $2, $3, $4)
ON CONFLICT (document_id, tag_id) DO UPDATE
SET attributes = EXCLUDED.attributes,
    attributes_metadata = EXCLUDED.attributes_metadata,
    modified_at = NOW()
`

func (q *Queries) AddDocumentTag(ctx context.Context, documentID pgtype.UUID, tagID pgtype.UUID, attributes []byte, attributesMetadata []byte) error {
	_, err := q.db.Exec(ctx, addDocumentTag,
		documentID,
		tagID,
		attributes,
		attributesMetadata,
	)
	return err
}

const getDocumentTagAttributes = `-- name: GetDocumentTagAttributes :one

SELECT attributes, attributes_metadata
FROM document_tags
WHERE document_id = $1 AND tag_id = $2
`

type GetDocumentTagAttributesRow struct {
	Attributes         []byte `json:"attributes"`
	AttributesMetadata []byte `json:"attributes_metadata"`
}

// --------- Tag-specific attributes -----------
func (q *Queries) GetDocumentTagAttributes(ctx context.Context, documentID pgtype.UUID, tagID pgtype.UUID) (GetDocumentTagAttributesRow, error) {
	row := q.db.QueryRow(ctx, getDocumentTagAttributes, documentID, tagID)
	var i GetDocumentTagAttributesRow
	err := row.Scan(&i.Attributes, &i.AttributesMetadata)
	return i, err
}

const getDocumentTagsWithAttributes = `-- name: GetDocumentTagsWithAttributes :many
SELECT t.id, t.namespace_id, t.name, t.path, dt.attributes, dt.attributes_metadata, dt.modified_at
FROM tags t
JOIN document_tags dt ON t.id = dt.tag_id
WHERE dt.document_id = $1
`

type GetDocumentTagsWithAttributesRow struct {
	ID                 pgtype.UUID        `json:"id"`
	NamespaceID        pgtype.UUID        `json:"namespace_id"`
	Name               string             `json:"name"`
	Path               string             `json:"path"`
	Attributes         []byte             `json:"attributes"`
	AttributesMetadata []byte             `json:"attributes_metadata"`
	ModifiedAt         pgtype.Timestamptz `json:"modified_at"`
}

func (q *Queries) GetDocumentTagsWithAttributes(ctx context.Context, documentID pgtype.UUID) ([]GetDocumentTagsWithAttributesRow, error) {
	rows, err := q.db.Query(ctx, getDocumentTagsWithAttributes, documentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDocumentTagsWithAttributesRow{}
	for rows.Next() {
		var i GetDocumentTagsWithAttributesRow
		if err := rows.Scan(
			&i.ID,
			&i.NamespaceID,
			&i.Name,
			&i.Path,
			&i.Attributes,
			&i.AttributesMetadata,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeDocumentTag = `-- name: RemoveDocumentTag :exec
DELETE FROM document_tags
WHERE document_id = $1 AND tag_id = $2
`

func (q *Queries) RemoveDocumentTag(ctx context.Context, documentID pgtype.UUID, tagID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, removeDocumentTag, documentID, tagID)
	return err
}

const updateDocumentTagAttributes = `-- name: UpdateDocumentTagAttributes :exec
UPDATE document_tags
SET attributes = $3, attributes_metadata = $4, modified_at = NOW()
WHERE document_id = $1 AND tag_id = $2
`

func (q *Queries) UpdateDocumentTagAttributes(ctx context.Context, documentID pgtype.UUID, tagID pgtype.UUID, attributes []byte, attributesMetadata []byte) error {
	_, err := q.db.Exec(ctx, updateDocumentTagAttributes,
		documentID,
		tagID,
		attributes,
		attributesMetadata,
	)
	return err
}
